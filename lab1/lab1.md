



# 扩展联系challenge1

## 题目

回答：描述ucore中处理中断异常的流程（从异常的产生开始），其中mov a0，sp的目的是什么？SAVE_ALL中寄寄存器保存在栈中的位置是什么确定的？对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由。

## 回答

### 处理中断异常的流程

- 中断发生时，cpu跳转至stvec
- 在Direct模式下，stvec中储存了中断处理程序的入口点，直接跳转
- 调用SAVE_ALL保存上下文到栈中
- 调用trap处理中断，并传入当前栈指针
- 如何调用RESTORE_ALL恢复状态
- sret返回被中断的地址

### mov a0，sp的目的是什么？

- 之前的SAVE_ALL将寄存器都存到了栈上
- a0可以对调用的函数进行传参
- 所以调用的函数（trap）可以访问刚刚保存的上下文信息

### SAVE_ALL中寄存器保存在栈中的位置是什么确定的？

- 保存在栈顶
- 由当前的栈顶位置确定

### __alltraps 中都需要保存所有寄存器

- 因为在中断处理过程中，CPU的状态可能会被改变。保存所有寄存器能够确保在中断处理完成后，程序能够从中断前的状态恢复，避免丢失任何上下文信息。



# 不懂的问题：

##  为什么内核镜像被加载到0x80200000?

因为QEMU的OpenSBI中加载内核镜像的代码是**地址相关**的。

## 为什么要得到**内存布局合适**的elf文件？

最小可执行内核里, 我们主要完成两件事:

1. 内核的**内存布局**和入口点设置
2. 通过sbi封装好输入输出函数

## gnu工具链是什么？

GNU工具链是一组由GNU项目开发的开源编程工具，主要用于软件开发和编译。它通常包括编译器（如GCC）、汇编器、链接器（如ld）、调试器（如GDB）以及其他工具。GNU工具链广泛用于各种平台，特别是在Unix/Linux系统上，帮助开发人员创建、编译和调试程序。

## 我们通过连接器ld获取操作系统内核的elf文件（输出文件）时的输入文件（.O文件）是什么？



在获取操作系统内核的ELF文件时，输入文件通常是由编译器生成的目标文件（.o文件）。这些目标文件包含了编译后的代码和数据段，如.text、.data、.bss等，经过汇编和链接后，它们被合并成一个可执行的内核映像。具体来说，输入文件可能包括：

1. **内核模块的目标文件**：如系统调用、驱动程序和其他内核组件的编译结果。
2. **启动代码**：用于初始化系统的代码段，例如引导程序和入口点的汇编文件。
3. **库文件**：如果内核依赖于某些库或公共代码，这些文件也会作为输入。

通过链接器ld，这些目标文件的各个部分会根据链接脚本中的指示进行组合，生成最终的ELF格式的内核映像。

> 可能是需要我们之后自己实现的

## 为什么ld默认的链接脚本不适合链接一个操作系统内核，或者说链接一个操作系统内核时，有什么需要满足的特征吗？

ld默认的链接脚本通常是为用户空间程序设计的，不适合链接操作系统内核，主要因为以下特征：

1. **内存布局要求**：内核需要特定的内存布局，如将代码和数据段放置在物理内存的特定地址（如0x80000000或0x80200000），而用户程序通常使用动态地址分配。

2. **入口点**：内核有一个特定的入口点，通常是汇编代码中的一个标签，需要在链接脚本中明确指定，而用户程序的入口点通常是main函数。

3. **段的处理**：内核需要区分不同类型的内存段（如只读、读写、未初始化），而默认脚本可能未考虑这些特性，导致无法正确管理内存。

4. **没有操作系统支持的功能**：内核通常需要直接与硬件交互，而用户程序运行在操作系统提供的抽象层上，默认脚本的设置不适合这种低级别的控制。

5. **启动代码的支持**：内核可能需要引导代码以初始化硬件或设置内存，而默认脚本不一定包含这些要求。

因此，链接内核时需要自定义链接脚本，以满足这些特定需求。

## riscv语法问题：

### la指令的用法是什么？

`la`（load address）指令用于加载一个标签的地址到寄存器中。其基本用法是：

```assembly
la destination, label
```

这里，`destination`是目标寄存器，`label`是你要加载地址的标签。使用`la`可以获取数据段、代码段或其他段的地址，常用于初始化指针或设置栈顶。例如：

```assembly
la sp, bootstacktop  # 将bootstacktop的地址加载到栈指针寄存器sp
```

在这个例子中，`sp`将指向`bootstacktop`的内存地址，为后续的栈操作做好准备。

### tail的用法是什么？

在RISC-V汇编语言中，`tail`指令用于无条件跳转到指定的标签，同时确保不保存当前指令的返回地址。这意味着执行跳转后不会返回到调用点，适合用于实现递归或特定的控制流结构。

基本用法如下：

```assembly
tail label
```

这里，`label`是你要跳转到的目标标签。使用`tail`指令时，通常是为了优化某些函数调用，特别是在将要执行递归或其他形式的尾调用时。

例如：

```assembly
tail kern_init  # 跳转到kern_init，不保存返回地址
```

在这个例子中，控制流将直接跳转到`kern_init`，后续不会返回到跳转前的代码。这有助于节省栈空间，因为不需要在调用时保留返回地址。



## 什么是glibc，以及glibc提供的运行时环境？

glibc（GNU C Library）是GNU项目的C标准库，提供了C语言的标准函数和系统调用接口。它包含了基本的输入输出、字符串处理、内存管理等功能。

glibc提供的运行时环境包括初始化程序、线程管理、内存分配和系统调用的封装，使得C程序能够与操作系统进行交互。例如，glibc负责处理文件操作、进程控制和信号处理等，使得开发者可以更方便地编写与操作系统交互的程序。由于在ucore中没有glibc，因此需要自己实现这些功能。

## 为什么中断可以处理异常？

中断可以处理异常是因为中断机制允许系统在遇到异常情况时暂停当前执行的程序，并转而执行异常处理程序（M模式）。

## CSR是什么？

CSR（Control and Status Register）是控制和状态寄存器的缩写，是RISC-V架构中的特殊寄存器，用于控制处理器的行为和状态信息。CSR包含了多种功能，包括中断使能、异常处理、特权模式设置等。通过读写这些寄存器，软件可以控制处理器的操作模式，获取异常信息，并管理系统的资源和安全性。CSR是实现操作系统和硬件交互的重要接口。

## `stval`寄存器是什么？

当我们触发中断进入 S 态进行处理时，以下寄存器会被硬件自动设置，将一些信息提供给中断处理程序：

**sepc**(supervisor exception program counter)，它会记录触发中断的那条指令的地址；

**scause**，它会记录中断发生的原因，还会记录该中断是不是一个外部中断；

**stval**，它会记录一些中断处理所需要的辅助信息，比如指令获取(instruction fetch)、访存、缺页异常，它会把发生问题的目标地址或者出错的指令记录下来，这样我们在中断处理程序中就知道处理目标了。

## 怎么运行？

make qemu

## 如何停止？

调用sbi.h中的shut_down()函数关机

